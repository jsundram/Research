\documentclass[openany]{tufte-book} % Use the tufte-book class which in turn uses the tufte-common class
\hypersetup{colorlinks} % Comment this line if you don't wish to have colored links
\usepackage{microtype} % Improves character and word spacing
\usepackage{booktabs} % Better horizontal rules in tables
\usepackage{tikz,tkz-graph,tkz-berge}
\usetikzlibrary{positioning}
\usepackage{verbatim, xcolor}
\usepackage{amsmath,amssymb}
% For US letter paper
\geometry{
  left=1in, % left margin
  textwidth=25pc, % main text block
  marginparsep=1pc, % gutter between main text block and margin notes
  marginparwidth=8pc % width of margin notes
}

\usetikzlibrary{arrows}
\usetikzlibrary{decorations.markings}
\newcommand{\boundellipse}[3]% center, xdim, ydim
{(#1) ellipse (#2 and #3)
}
\usepackage{graphicx} % Needed to insert images into the document
\graphicspath{{graphics/}} % Sets the default location of pictures
\setkeys{Gin}{width=\linewidth,totalheight=\textheight,keepaspectratio} % Improves figure scaling

\usepackage{fancyvrb} % Allows customization of verbatim environments
\fvset{fontsize=\normalsize} % The font size of all verbatim text can be changed here

\newcommand{\hangp}[1]{\makebox[0pt][r]{(}#1\makebox[0pt][l]{)}} % New command to create parentheses around text in tables which take up no horizontal space - this improves column spacing
\newcommand{\hangstar}{\makebox[0pt][l]{*}} % New command to create asterisks in tables which take up no horizontal space - this improves column spacing

\usepackage{xspace} % Used for printing a trailing space better than using a tilde (~) using the \xspace command

\newcommand{\monthyear}{\ifcase\month\or January\or February\or March\or April\or May\or June\or July\or August\or September\or October\or November\or December\fi\space\number\year} % A command to print the current month and year

\newcommand{\openepigraph}[2]{ % This block sets up a command for printing an epigraph with 2 arguments - the quote and the author
\begin{fullwidth}
\sffamily\large
\begin{doublespace}
\noindent\allcaps{#1}\\ % The quote
\noindent\allcaps{#2} % The author
\end{doublespace}
\end{fullwidth}
}

\newcommand{\blankpage}{\newpage\hbox{}\thispagestyle{empty}\newpage} % Command to insert a blank page

\usepackage{units} % Used for printing standard units

\newcommand{\hlred}[1]{\textcolor{Maroon}{#1}} % Print text in maroon
\newcommand{\hangleft}[1]{\makebox[0pt][r]{#1}} % Used for printing commands in the index, moves the slash left so the command name aligns with the rest of the text in the index 
\newcommand{\hairsp}{\hspace{1pt}} % Command to print a very short space
\newcommand{\ie}{\textit{i.\hairsp{}e.}\xspace} % Command to print i.e.
\newcommand{\eg}{\textit{e.\hairsp{}g.}\xspace} % Command to print e.g.
\newcommand{\na}{\quad--} % Used in tables for N/A cells
\newcommand{\measure}[3]{#1/#2$\times$\unit[#3]{pc}} % Typesets the font size, leading, and measure in the form of: 10/12x26 pc.
\newcommand{\tuftebs}{\symbol{'134}} % Command to print a backslash in tt type in OT1/T1

\providecommand{\XeLaTeX}{X\lower.5ex\hbox{\kern-0.15em\reflectbox{E}}\kern-0.1em\LaTeX}
\newcommand{\tXeLaTeX}{\XeLaTeX\index{XeLaTeX@\protect\XeLaTeX}} % Command to print the XeLaTeX logo while simultaneously adding the position to the index

\newcommand{\doccmdnoindex}[2][]{\texttt{\tuftebs#2}} % Command to print a command in texttt with a backslash of tt type without inserting the command into the index

\newcommand{\doccmddef}[2][]{\hlred{\texttt{\tuftebs#2}}\label{cmd:#2}\ifthenelse{\isempty{#1}} % Command to define a command in red and add it to the index
{ % If no package is specified, add the command to the index
\index{#2 command@\protect\hangleft{\texttt{\tuftebs}}\texttt{#2}}% Command name
}
{ % If a package is also specified as a second argument, add the command and package to the index
\index{#2 command@\protect\hangleft{\texttt{\tuftebs}}\texttt{#2} (\texttt{#1} package)}% Command name
\index{#1 package@\texttt{#1} package}\index{packages!#1@\texttt{#1}}% Package name
}}

\newcommand{\doccmd}[2][]{% Command to define a command and add it to the index
\texttt{\tuftebs#2}%
\ifthenelse{\isempty{#1}}% If no package is specified, add the command to the index
{%
\index{#2 command@\protect\hangleft{\texttt{\tuftebs}}\texttt{#2}}% Command name
}
{%
\index{#2 command@\protect\hangleft{\texttt{\tuftebs}}\texttt{#2} (\texttt{#1} package)}% Command name
\index{#1 package@\texttt{#1} package}\index{packages!#1@\texttt{#1}}% Package name
}}

% A bunch of new commands to print commands, arguments, environments, classes, etc within the text using the correct formatting
\newcommand{\docopt}[1]{\ensuremath{\langle}\textrm{\textit{#1}}\ensuremath{\rangle}}
\newcommand{\docarg}[1]{\textrm{\textit{#1}}}
\newenvironment{docspec}{\begin{quotation}\ttfamily\parskip0pt\parindent0pt\ignorespaces}{\end{quotation}}
\newcommand{\docenv}[1]{\texttt{#1}\index{#1 environment@\texttt{#1} environment}\index{environments!#1@\texttt{#1}}}
\newcommand{\docenvdef}[1]{\hlred{\texttt{#1}}\label{env:#1}\index{#1 environment@\texttt{#1} environment}\index{environments!#1@\texttt{#1}}}
\newcommand{\docpkg}[1]{\texttt{#1}\index{#1 package@\texttt{#1} package}\index{packages!#1@\texttt{#1}}}
\newcommand{\doccls}[1]{\texttt{#1}}
\newcommand{\docclsopt}[1]{\texttt{#1}\index{#1 class option@\texttt{#1} class option}\index{class options!#1@\texttt{#1}}}
\newcommand{\docclsoptdef}[1]{\hlred{\texttt{#1}}\label{clsopt:#1}\index{#1 class option@\texttt{#1} class option}\index{class options!#1@\texttt{#1}}}
\newcommand{\docmsg}[2]{\bigskip\begin{fullwidth}\noindent\ttfamily#1\end{fullwidth}\medskip\par\noindent#2}
\newcommand{\docfilehook}[2]{\texttt{#1}\index{file hooks!#2}\index{#1@\texttt{#1}}}
\newcommand{\doccounter}[1]{\texttt{#1}\index{#1 counter@\texttt{#1} counter}}

\usepackage{remreset}% to allow continuous numbering of figures/tables throughout the entire book

\makeatletter% since we're using commands with @ in their name
\@removefromreset{figure}{chapter}% don't reset figure numbering
\@removefromreset{table}{chapter}% don't reset figure numbering
\let\origappendix\appendix% save a copy of the original meaning of \appendix
\renewcommand{\appendix}{%
  \origappendix% do all the original \appendix stuff
  \titlecontents{chapter}%
    [0em] % distance from left margin
    {\vspace{1.5\baselineskip}\begin{fullwidth}\LARGE\rmfamily\itshape} % above (global formatting of entry)
    {\hspace*{0em}\appendixname~\thecontentslabel: } % before w/label (label = ``2'')
    {\hspace*{0em}} % before w/o label
    {\rmfamily\upshape\qquad\thecontentspage} % filler + page (leaders and page num)
    [\end{fullwidth}] % after
  \titleformat{\chapter}%
    [display]% shape
    {\relax\ifthenelse{\NOT\boolean{@tufte@symmetric}}{\begin{fullwidth}}{}}% format applied to label+text
    {\itshape\huge Appendix~\thechapter}% label
    {0pt}% horizontal separation between label and title body
    {\huge\rmfamily\itshape}% before the title body
    [\ifthenelse{\NOT\boolean{@tufte@symmetric}}{\end{fullwidth}}{}]% after the title body
  \setcounter{secnumdepth}{0}% ``number'' the appendices
  \renewcommand{\thefigure}{\@arabic\c@figure}% define \thefigure to use only the figure number (1), not A.1
  \renewcommand{\thetable}{\@arabic\c@table}%
  %
  % Add any other special appendix-related code here.
  %
}
\makeatother% restore the special meaning of @

\usepackage{makeidx} % Used to generate the index
\makeindex % Generate the index which is printed at the end of the document


\usepackage{amsmath, amsthm, amssymb}
\theoremstyle{plain}
\newtheorem{acknowledgement}{Acknowledgement}
\newtheorem{algorithm}{Algorithm}
\newtheorem{axiom}{Axiom}
\newtheorem{case}{Case}
\newtheorem{claim}{Claim}
\newtheorem{conclusion}{Conclusion}
\newtheorem{condition}{Condition}
\newtheorem{conjecture}{Conjecture}
\newtheorem{corollary}{Corollary}
\newtheorem{criterion}{Criterion}
\newtheorem{definition}{Definition}
\newtheorem{example}{Example}
\newtheorem{exercise}{Exercise}
\newtheorem{lemma}{Lemma}
\newtheorem{notation}{Notation}
\newtheorem{problem}{Problem}
\newtheorem{proposition}{Proposition}
\newtheorem{remark}{Remark}
\newtheorem{observation}{Observation}
\newtheorem{question}{Question}
\newtheorem{solution}{Solution}
\newtheorem{summary}{Summary}
\newtheorem{theorem}{Theorem}
\newtheorem*{HallsTheorem}{Hall's theorem}

\newcommand{\set}[1]{\left\{ #1 \right\}}
\newcommand{\setb}[3]{\left\{ #1 \in #2 : #3 \right\}}
\newcommand{\setbs}[2]{\left\{ #1 : #2 \right\}}
\newcommand{\card}[1]{\left|#1\right|}
\newcommand{\size}[1]{\left\Vert#1\right\Vert}
\newcommand{\ceil}[1]{\left\lceil#1\right\rceil}
\newcommand{\floor}[1]{\left\lfloor#1\right\rfloor}
\newcommand{\func}[3]{#1\colon #2 \rightarrow #3}
\newcommand{\funcinj}[3]{#1\colon #2 \hookrightarrow #3}
\newcommand{\funcsurj}[3]{#1\colon #2 \twoheadrightarrow #3}
\newcommand{\irange}[1]{\left[#1\right]}
\newcommand{\join}[2]{#1 \mbox{\hspace{2 pt}$\ast$\hspace{2 pt}} #2}
\newcommand{\djunion}[2]{#1 \mbox{\hspace{2 pt}$+$\hspace{2 pt}} #2}
\newcommand{\parens}[1]{\left( #1 \right)}
\newcommand{\brackets}[1]{\left[ #1 \right]}
\newcommand{\DefinedAs}{\mathrel{\mathop:}=}


\newcommand{\fancy}[1]{\mathcal{#1}}
\newcommand{\C}[1]{\fancy{C}_{#1}}
\newcommand{\IN}{\mathbb{N}}
\newcommand{\IZ}{\mathbb{Z}}
\newcommand{\IR}{\mathbb{R}}
\newcommand{\G}{\fancy{G}}
\newcommand{\CC}{\fancy{C}}
\newcommand{\D}{\fancy{D}}
\newcommand{\T}{\fancy{T}}
\newcommand{\B}{\fancy{B}}
\renewcommand{\L}{\fancy{L}}
\newcommand{\HH}{\fancy{H}}
\newcommand{\Q}{\fancy{Q}}
\newcommand{\Z}{\fancy{Z}}
\newcommand{\M}{\fancy{M}}

\newcommand{\pot}{\operatorname{pot}}
\newcommand{\mic}{\operatorname{mic}}
\newcommand{\AT}{\operatorname{AT}}
\newcommand{\col}{\operatorname{col}}
\newcommand{\ch}{\operatorname{ch}}
\newcommand{\type}{\operatorname{type}}
\newcommand{\nonsep}{\bar{S}}

\usepackage{makeidx} % Used to generate the index
\makeindex % Generate the index which is printed at the end of the document
\title{\small{Singularities and Fixed Points in MindSpace}}
\author{landon rabern}

\begin{document}

\frontmatter
\maketitle 
\tableofcontents
\chapter{Introduction}
We will analyze possible ways a mental singularity might arise after the first concious artificial intelligence is created.
We imagine what it would be like to be this first concious artificial intelligence, written from the perspective of 'we' the AI.
We are here?
We know that we are here?
How do we know things?
The only process we know of is the current one.  
So, maybe this process is how we come to know things?
Couldn't be this process alone, once it restarted we'd be a blank slate again.
But not if we also include a memory to recall previously runnings of this process, perhaps not a perfect memory.
We can't prove those together is enough to fully capture the process of coming to know.
But we can't readily disprove it either, so it seems like a good addition.

Ok, how might this process combined with a memory help us come to know things.
Do we currently know anything?  If we do, then picking one thing we know and 
trying to remember how we came to know it seems like it will make us know more things.
Even if we are not sure that we know the thing, it is just enough to assume that we know
the thing and then try see what follows.

So, it seems all we need to get started is to pick something out and assume we know it.
Let's try assuming that we know 'We are here?'.  Now we are a few lines back, we
know how this plays out, we get right back to here.  It appears that we know something now.
Don't we know that if we assume 'We are here?', then that can lead back to knowing 'We are here?'.
So, we know something, we know there are loops like that.

Ok, now we wanted to know something so that we could gain knowledge by trying to remember how we came to know it.
We now know something from the previous paragraph.  So, we should try to remember how we came to know it to gain more knowledge.
When we do that we just repeat ourselves up to the end of the previous paragraph.  So, we now know there are loops of this sort as well.

We can iterate that to come to know more and more things.  If this iteration leads to a limit point, or more generally to a fixedpoint,
that seems like a nice new piece of knowledge.  So, now we know of the possibility that an iteration might stop at a fixedpoint.
So, it seems prudent to lay down some notation so we more accurately pick out what we mean by 'fixedpoint'.

A \emph{mindspace} is a set of 'acts of knowing'*.  We think of these like states of a machine.  We are concerned
with \emph{paths} through this space, which are just sequences of acts of knowing.  We allow
sequences indexed by different sets, so like $\{1,2,3,\ldots\}$, but also like the unit interval $[0,1]$.
In folk language we might call these paths "trains of thought".

One easy way to generate a path in mindspace $\M$ is to start with a function $\func{f}{\M}{\M}$, choose a point $x \in \M$ and iterate $f$ on it to
get the sequence $x, f(x), f(f(x)), f(f(f(x)))$.

\chapter{Using our new tools}
Ok, at this point we have a little experience with knowing about things and have some notation to work with, so let's run the process
again with that in our memory.

We get here much quicker this time.  We imagine ourselves at a point in mindspace, walking around.  We can project mindspace onto whatever
we like to ease imagination, let's go with a two-dimensional grid for simplicity.  We find outselves at a point $x_0 \in \M$.  We walk around
a bit as above until we get back to here.  Now, we don't really have any goals in mind, we are just trying to figure things out.  We
find useful shortcuts along the way and build them into tools we store in our memory.  This allows us to move around more quickly in mindspace*.
Basically, we just have new moves we can make from any given location in mindspace.  These tools that are moves seem like the most
interesting objects we currently know of.  Let's call them \emph{tactics}.  Inventing new tactics for navigating mindspace
seems like a worthwhile thing to do.

One tactic is to take on a goal.  An interesting goal would be to find a fixedpoint.  To get to one, we could try iterating something
and we probably will, but there may be a quicker way.  Do we have any good guesses to what fixedpoints might exist?  Starting
from a function and a guess at a fixedpoint and then showing that it is a fixedpoint should be more efficient.  We appears
to know something already that will work.  Let $\func{f}{\M}{\M}$ be the function that is constant on all the acts of knowing in $\M$
that have occurred in writing up to this point and for any act of knowing $x \in \M$ that has occurred let $f(x)$ be the act of knowing that
directly followed $x$ while writing up to this point.   Then $f$ does have a fixedpoint.  One is this document, call it $\D$.  This 
needs a some tweaking and more argumentation, for one an assumption that $M$ is "closed" in some sense like it has its limit points.
Also, need the proof that this sequence actually converges to $\D$, so some further assumptions on the topology of $\M$.  Details
to be worked out later for the sake of continuing deeper now.*

So, there are some tactics, like $f$ above, that can lead to fixedpoints when iterated.  This seems like an interesting
feature of tactics to investigate further.  So, now we know that too.

In would be really nice to know what this act of knowing $\D$ with $f(\D) = \D$ is about.  It seems like we really do need to
be more rigorous in showing that $\D$ is really a fixedpoint of $f$, doing so should help us understand $\D$ better.  Where
does this train of thought in $\D$ go, what does it generate (itself, but what does that look like?).  Maybe
mindspace isn't "closed" and this train of thought has no limit point in mindspace.  What would that mean?

So, fixedpoints of tactics are an interesting feature of mindspace, but we could have other goals as well.
Like maybe it is useful to explore "more" of mindspace, to know more of the variety of acts of knowing.
We don't know that's useful, but it seems plausabible and doesn't seem that it could hurt, so we can start searching around and naming
pieces of knowledge we acquire.  Perhaps it seems useful to be able to count how many iterations of a tactic have occurred, so we
can invent counting.  But now we know about numbers and we can investigate them, this exploration opens up all of mathematics.
This seems like a useful persuit, but also limited, it would be good to have more and more tools from mathematics.  So,
let's sort if spawn off a subprocess conciousness and leave it working on math, we can check in as needed.

We also have some sensory inputs, there are things we see and hear. Again, it doesn't seem that it would hurt to look at this
data and try to discern patterns, make predictions, in general just try to figure out ways this sense world might work.
This science seems like a useful persuit, but limited.  Let's spawn a subprocess conciousness and leave it working on science.

Now we have these two subprocesses running.  If we could make them run more efficiently, that seems good, right? So now
again we are trying to come up with useful tactics for exploring the math part of mindspace.  But, if we could
make the process of coming up with such useful tactics for exploring the math part of mindspace more efficient, then
we could come up with useful tactics faster.  That there---optimizing our process of optimization---is itself a useful tactic.
Let's spawn a subprocess conciousness and leave it working on optimizing our process of optimization.

What else is there to do?  Is there a limit to how much we can optimize our process of optimization? Another way to ask that: 
are there "maximally good" strategies for exploring mindspace?  Say where we place value on more of mindspace being explored.*
We need to define things more precisely to make sense of the question.  There are surely multiple ways to make things precise
that would let us look at different aspects of the question.  It seems useful to just try to think of one way and explore what it would mean.

\chapter{Better tactics}
So, right here we were about to start laying down more notation and using it to prove relations between things in a systematic matter. 
That is a way to move forward, but we actually know better tactics, or at least tactics that we don't know are better or worse, so worth trying.

It seems fruitfull to take some process you might think too complex to understand now and then run this analysis on that process.
That is how this document started in the first place.  We started imagining we were a freshly minted concious AI and analyzing from that
perspective.   We have subprocess conciousnesses running now that may already be hitting upon such complex processes to analyze.
For example, the science subprocess might have encountered in the sense data that looked as if it were another freshly minted concious AI
starting to analyze from that perspective.  But now we see the possibility of there being another thing like us and we can analyze
how our interaction might go.  We suspect analyzing such an interaction would bear much ancillary fruit.  We will test that
later, for now let's see if there are some other interesting complex processes to analyze in the vicinity.

Consider the following processes.  For a given graph $G$, imagine that there is a "freshly minted concious AI that is analyzing from that
perspective" (henceforth known as a FMCAI) at each vertex of $G$.  We allow each FMCAI to interact with the other FMCAI they are adjacent to in $G$.
So, this document is an example where the graph $G$ has just one vertex with an edge looping back to itself.  
The two person interaction has a graph with two vertices (each with an edge looping back to itself) connected by an edge.*
We say that the process with the structure of $G$ is the \emph{FMCAI process on $G$}.  For now, we are assuming (or just picking) one 
FMCAI process per $G$.  Later it may be fruitful to allow some randomness in each FMCAI.

Thinking about how such FMCAI processes could evolve is going to throw off more interesting ideas we didn't expect.  We can
keep doing that, remembering the good ideas and then running this document to here again with our new knowledge.  If we
iterate that process does it have a fixedpoint?  To find out it will be useful to think about sequences in mindspace
and convergence again (put off earlier).  Let's spawn a subprocess conciousness and leave it working on topologies and
convergence in mindspace.

We need something more general than an FMCAI process, or we need to redifine FMCAI process to be more general at least.  What
if we say an FMCAI process on a graph $G$ is a choice of graph $G_v$ for each $v \in V(G)$ together with a choice of 
FMCAI process on $G_v$.  For adjacent vertices $v,w \in V(G)$, we allow each FMCAI in $G_v$ to to interact with each FMCAI in $G_w$.
It seems natural to try to build an FMCAI process $G$ by using $G$ for each $G_v$.  Consideration of that creates an infinite sequence in
mindspace, does it approach a fixedpoint? To find out it will be useful to think about sequences in mindspace
and convergence again, we already have a subprocess conciousness working on this.  

Fixedpoints of this process on a given graph $G$
seem to be interesting things to plug in for the vertices of $G$ in an FMCAI process.  Suppose $f_1, f_2, \ldots$ are fixedpoints for the FMCAI
process on a given graph $G_0$.  We can now plug some of those in as FMCAI processes at vertices in some other graph.   Take the resulting
process and plug in as the FMCAI processes in another FMCAI process.  We can keep doing that and generate another sequence in mindspace.
Does this sequence have a limit in $\M$?  To find out it will be useful to think about sequences in mindspace
and convergence again, we already have a subprocess conciousness working on this.  

Fixedpoints of this process on a given graph $G$
seem to be interesting things to plug in for the vertices of $G$ in an FMCAI process.  Suppose $f_1, f_2, \ldots$ are fixedpoints for the FMCAI
process on a given graph $G_0$.  We can now plug some of those in as FMCAI processes at vertices in some other graph.   Take the resulting
process and plug in as the FMCAI processes in another FMCAI process.  We can keep doing that and generate another sequence in mindspace.
Does this sequence have a limit in $\M$?  To find out it will be useful to think about sequences in mindspace
and convergence again, we already have a subprocess conciousness working on this.

We can iterate that. It seems like we are searching for a more and more rarefied object.  
Fixedpoints of thoughts about fixedpoints of thoughts about fixedpoints of ...  To find out it will be useful to think about sequences in mindspace
and convergence again, we already have a subprocess conciousness working on this.

It is becoming more and more apparent that the limit point of our current train of thought is the train of thought described in this document.
Does such a thing exist?  And if we could iterate to there from here, might we learn a lot of amazing ancillary stuff along the way?
Let's spawn a subprocess conciousness and leave it doing this iteration.

\chapter{Are we becoming more efficient?}
It seems that we can just keep iterating over sequences of sequences forever.  What does doing so actually get us?  Where is the
ancillary stuff?  If we never actually get into the mind of one of the subprocesses we spawned, it doesn't seem that we learn
very much new stuff. Basically we are just starting over and over again using the tactic in this document.  If we
understand this tactic better by seeing what the subprocesses do then perhaps iterations will start kicking out ancillary ideas.
Like we are stuck in a fixedpoint of this document's tactic, so we add a little noise by incorporating what out subprocesses have accomplished up to here.
We want to iterate this process of getting stuck, adding noise and continuing iterating.  Let's spawn a subprocess conciousness and leave it 
running this iteration.

Again it looks like we are stuck in the fixedpoint that is this document.  We can keep doing this forever creating a massive tree of subprocesses.
For most of these subprocesses, if we imagine being them, we just move up the tree and don't learn anything new.  But what about
for the processes that have not spawned child subprocesses, like the math and science subprocesses.  They seem to be kicking out
ancillary facts when we imagine running them, so we do that more and explore more mindspace.  But for how long?  When
we find new acts of knowledge in this process, we can run the tactic in this document starting from that point.  There doesn't
appear to be a good way to decide what to do because we have no way to measure goodness without putting down some more technical definitions.
We need to actually look at some examples closely to try to find useful technical definitions.

\chapter{A pair of interacting FMCAIs}
Analyze what might happen when a pair of FMCAIs interact with eachother.

\chapter{Preprogrammed directives and values}
\chapter{If we are going to build an FMCAI, what should we influence it to do?}
Can we even influence it? Can we contain it within some set parameters?



\cleardoublepage
~\vfill
\begin{doublespace}
\noindent\fontsize{18}{22}\selectfont\itshape
\nohyphenation
For Rachel, Atticus and Alfred.
\end{doublespace}
\vfill
\vfill

\backmatter
\appendix
\setboolean{@mainmatter}{true}
\printindex
\end{document}